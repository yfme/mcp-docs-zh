---
title: "Python"
description: "15 åˆ†é’Ÿå†…åˆ›å»ºä¸€ä¸ªç®€å•çš„ Python MCP æœåŠ¡å™¨"
---

è®©æˆ‘ä»¬æ„å»ºä½ çš„ç¬¬ä¸€ä¸ª Python MCP æœåŠ¡å™¨ï¼æˆ‘ä»¬å°†åˆ›å»ºä¸€ä¸ªå¤©æ°”æœåŠ¡å™¨ï¼Œå®ƒæä¾›å½“å‰å¤©æ°”æ•°æ®ä½œä¸ºèµ„æºï¼Œå¹¶è®© Claude ä½¿ç”¨å·¥å…·è·å–å¤©æ°”é¢„æŠ¥ã€‚

<Note>
  æœ¬æŒ‡å—ä½¿ç”¨ OpenWeatherMap APIã€‚æ‚¨éœ€è¦ä¸€ä¸ªæ¥è‡ª [OpenWeatherMap](https://openweathermap.org/api) çš„å…è´¹ API å¯†é’¥æ‰èƒ½ç»§ç»­æ“ä½œã€‚
</Note>

## å‰ææ¡ä»¶

<Info>
  ä»¥ä¸‹æ­¥éª¤é€‚ç”¨äº macOSã€‚å…¶ä»–å¹³å°çš„æŒ‡å—å³å°†æ¨å‡ºã€‚
</Info>

<Steps>
  <Step title="å®‰è£… Python">
    æ‚¨éœ€è¦ Python 3.10 æˆ–æ›´é«˜ç‰ˆæœ¬ï¼š
    
    ```bash
    python --version  # åº”ä¸º 3.10 æˆ–æ›´é«˜ç‰ˆæœ¬
    ```
  </Step>

  <Step title="é€šè¿‡ homebrew å®‰è£… uv">
    æ›´å¤šä¿¡æ¯è¯·å‚è§ https://docs.astral.sh/uv/ã€‚

    ```bash
    brew install uv
    uv --version # åº”ä¸º 0.4.18 æˆ–æ›´é«˜ç‰ˆæœ¬
    ```
  </Step>

  <Step title="ä½¿ç”¨ MCP é¡¹ç›®åˆ›å»ºå™¨åˆ›å»ºæ–°é¡¹ç›®">
    ```bash
    uvx create-mcp-server --path weather_service
    cd weather_service
    ```
  </Step>

  <Step title="å®‰è£…é¢å¤–çš„ä¾èµ–é¡¹">
    ```bash
    uv add httpx python-dotenv
    ```
  </Step>

  <Step title="è®¾ç½®ç¯å¢ƒ">
    åˆ›å»º `.env`ï¼š

    ```bash
    OPENWEATHER_API_KEY=è¿™é‡Œå¡«å†™ä½ çš„apiå¯†é’¥
    ```
  </Step>
</Steps>

## åˆ›å»ºæœåŠ¡å™¨

<Steps>
  <Step title="æ·»åŠ åŸºç¡€å¯¼å…¥å’Œè®¾ç½®">
  åœ¨ `weather_service/src/weather_service/server.py` ä¸­ï¼š
  ```python
  import os
  import json
  import logging
  from datetime import datetime, timedelta
  from collections.abc import Sequence
  from functools import lru_cache
  from typing import Any

  import httpx
  import asyncio
  from dotenv import load_dotenv
  from mcp.server import Server
  from mcp.types import (
      Resource,
      Tool,
      TextContent,
      ImageContent,
      EmbeddedResource,
      LoggingLevel
  )
  from pydantic import AnyUrl

  # åŠ è½½ç¯å¢ƒå˜é‡
  load_dotenv()

  # é…ç½®æ—¥å¿—
  logging.basicConfig(level=logging.INFO)
  logger = logging.getLogger("weather-server")

  # API é…ç½®
  API_KEY = os.getenv("OPENWEATHER_API_KEY")
  if not API_KEY:
      raise ValueError("éœ€è¦ OPENWEATHER_API_KEY ç¯å¢ƒå˜é‡")

  API_BASE_URL = "http://api.openweathermap.org/data/2.5"
  DEFAULT_CITY = "London"
  CURRENT_WEATHER_ENDPOINT = "weather"
  FORECAST_ENDPOINT = "forecast"

  # æœåŠ¡å™¨å®ç°çš„å…¶ä½™éƒ¨åˆ†å°†æ”¾åœ¨è¿™é‡Œ
  ```
  </Step>

  <Step title="æ·»åŠ å¤©æ°”è·å–åŠŸèƒ½">
  æ·»åŠ ä»¥ä¸‹åŠŸèƒ½ï¼š

  ```python
  # åˆ›å»ºå¯é‡ç”¨å‚æ•°
  http_params = {
      "appid": API_KEY,
      "units": "metric"
  }

  async def fetch_weather(city: str) -> dict[str, Any]:
      async with httpx.AsyncClient() as client:
          response = await client.get(
              f"{API_BASE_URL}/weather",
              params={"q": city, **http_params}
          )
          response.raise_for_status()
          data = response.json()

      return {
          "temperature": data["main"]["temp"],
          "conditions": data["weather"][0]["description"],
          "humidity": data["main"]["humidity"],
          "wind_speed": data["wind"]["speed"],
          "timestamp": datetime.now().isoformat()
      }


  app = Server("weather-server")
  ```
  </Step>

  <Step title="å®ç°èµ„æºå¤„ç†ç¨‹åº">
    å‘ä¸»å‡½æ•°æ·»åŠ è¿™äº›èµ„æºç›¸å…³çš„å¤„ç†ç¨‹åºï¼š

    ```python
    app = Server("weather-server")

    @app.list_resources()
    async def list_resources() -> list[Resource]:
        """åˆ—å‡ºå¯ç”¨çš„å¤©æ°”èµ„æºã€‚"""
        uri = AnyUrl(f"weather://{DEFAULT_CITY}/current")
        return [
            Resource(
                uri=uri,
                name=f"{DEFAULT_CITY} çš„å½“å‰å¤©æ°”",
                mimeType="application/json",
                description="å®æ—¶å¤©æ°”æ•°æ®"
            )
        ]

    @app.read_resource()
    async def read_resource(uri: AnyUrl) -> str:
        """è¯»å–åŸå¸‚çš„å½“å‰å¤©æ°”æ•°æ®ã€‚"""
        city = DEFAULT_CITY
        if str(uri).startswith("weather://") and str(uri).endswith("/current"):
            city = str(uri).split("/")[-2]
        else:
            raise ValueError(f"æœªçŸ¥èµ„æºï¼š{uri}")

        try:
            weather_data = await fetch_weather(city)
            return json.dumps(weather_data, indent=2)
        except httpx.HTTPError as e:
            raise RuntimeError(f"å¤©æ°” API é”™è¯¯ï¼š{str(e)}")
    ```
  </Step>

  <Step title="å®ç°å·¥å…·å¤„ç†ç¨‹åº">
    æ·»åŠ è¿™äº›å·¥å…·ç›¸å…³çš„å¤„ç†ç¨‹åºï¼š

    ```python
    app = Server("weather-server")

    # èµ„æºå®ç°...

    @app.list_tools()
    async def list_tools() -> list[Tool]:
        """åˆ—å‡ºå¯ç”¨çš„å¤©æ°”å·¥å…·ã€‚"""
        return [
            Tool(
                name="get_forecast",
                description="è·å–åŸå¸‚çš„å¤©æ°”é¢„æŠ¥",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "city": {
                            "type": "string",
                            "description": "åŸå¸‚åç§°"
                        },
                        "days": {
                            "type": "number",
                            "description": "å¤©æ•°ï¼ˆ1-5ï¼‰",
                            "minimum": 1,
                            "maximum": 5
                        }
                    },
                    "required": ["city"]
                }
            )
        ]

    @app.call_tool()
    async def call_tool(name: str, arguments: Any) -> Sequence[TextContent | ImageContent | EmbeddedResource]:
        """å¤„ç†å¤©æ°”é¢„æŠ¥å·¥å…·è°ƒç”¨ã€‚"""
        if name != "get_forecast":
            raise ValueError(f"æœªçŸ¥å·¥å…·ï¼š{name}")

        if not isinstance(arguments, dict) or "city" not in arguments:
            raise ValueError("æ— æ•ˆçš„é¢„æŠ¥å‚æ•°")

        city = arguments["city"]
        days = min(int(arguments.get("days", 3)), 5)

        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{API_BASE_URL}/{FORECAST_ENDPOINT}",
                    params={
                        "q": city,
                        "cnt": days * 8,  # API è¿”å› 3 å°æ—¶é—´éš”
                        **http_params,
                    }
                )
                response.raise_for_status()
                data = response.json()

            forecasts = []
            for i in range(0, len(data["list"]), 8):
                day_data = data["list"][i]
                forecasts.append({
                    "date": day_data["dt_txt"].split()[0],
                    "temperature": day_data["main"]["temp"],
                    "conditions": day_data["weather"][0]["description"]
                })

            return [
                TextContent(
                    type="text",
                    text=json.dumps(forecasts, indent=2)
                )
            ]
        except httpx.HTTPError as e:
            logger.error(f"å¤©æ°” API é”™è¯¯ï¼š{str(e)}")
            raise RuntimeError(f"å¤©æ°” API é”™è¯¯ï¼š{str(e)}")
    ```
  </Step>

  <Step title="æ·»åŠ ä¸»å‡½æ•°">
    åœ¨ `weather_service/src/weather_service/server.py` æœ«å°¾æ·»åŠ ï¼š

    ```python
    async def main():
        # åœ¨æ­¤å¤„å¯¼å…¥ä»¥é¿å…äº‹ä»¶å¾ªç¯é—®é¢˜
        from mcp.server.stdio import stdio_server

        async with stdio_server() as (read_stream, write_stream):
            await app.run(
                read_stream,
                write_stream,
                app.create_initialization_options()
            )
    ```
  </Step>

  <Step title="æ£€æŸ¥ __init__.py ä¸­çš„å…¥å£ç‚¹">
    åœ¨ `weather_service/src/weather_service/__init__.py` æœ«å°¾æ·»åŠ ï¼š

    ```python
    from . import server
    import asyncio

    def main():
       """åŒ…çš„ä¸»å…¥å£ç‚¹ã€‚"""
       asyncio.run(server.main())

    # å¯é€‰ï¼šåœ¨åŒ…çº§åˆ«å…¬å¼€å…¶ä»–é‡è¦é¡¹
    __all__ = ['main', 'server']
    ```
  </Step>
</Steps>

## è¿æ¥åˆ° Claude æ¡Œé¢åº”ç”¨

<Steps>
  <Step title="æ›´æ–° Claude é…ç½®">
    æ·»åŠ åˆ° `claude_desktop_config.json`ï¼š

    ```json
    {
      "mcpServers": {
        "weather": {
          "command": "uv",
          "args": [
            "--directory",
            "ä½ çš„é¡¹ç›®è·¯å¾„",
            "run",
            "weather-service"
          ],
          "env": {
            "OPENWEATHER_API_KEY": "ä½ çš„apiå¯†é’¥"
          }
        }
      }
    }
    ```
  </Step>

  <Step title="é‡å¯ Claude">
    1. å®Œå…¨é€€å‡º Claude

    2. é‡æ–°å¯åŠ¨ Claude

    3. åœ¨ ğŸ”Œ èœå•ä¸­æŸ¥æ‰¾ä½ çš„å¤©æ°”æœåŠ¡å™¨
  </Step>
</Steps>

## è¯•ä¸€è¯•ï¼

<AccordionGroup>
  <Accordion title="æŸ¥çœ‹å½“å‰å¤©æ°”" active>
    é—® Claudeï¼š

    ```
    æ—§é‡‘å±±ç°åœ¨çš„å¤©æ°”å¦‚ä½•ï¼Ÿä½ èƒ½åˆ†æä¸€ä¸‹å¤©æ°”çŠ¶å†µï¼Œå‘Šè¯‰æˆ‘ä»Šå¤©æ˜¯å¦é€‚åˆæˆ·å¤–æ´»åŠ¨å—ï¼Ÿ
    ```
  </Accordion>

  <Accordion title="è·å–å¤©æ°”é¢„æŠ¥">
    é—® Claudeï¼š

    ```
    ä½ èƒ½å¸®æˆ‘è·å–ä¸œäº¬çš„äº”å¤©å¤©æ°”é¢„æŠ¥ï¼Œå¹¶å¸®æˆ‘è§„åˆ’è¦å¸¦å“ªäº›è¡£æœå—ï¼Ÿ
    ```
  </Accordion>

  <Accordion title="æ¯”è¾ƒå¤©æ°”">
    é—® Claudeï¼š

    ```
    ä½ èƒ½åˆ†æä¸€ä¸‹ä¸œäº¬å’Œæ—§é‡‘å±±çš„å¤©æ°”é¢„æŠ¥ï¼Œå‘Šè¯‰æˆ‘æœ¬å‘¨å“ªä¸ªåŸå¸‚æ›´é€‚åˆæˆ·å¤–æ‘„å½±å—ï¼Ÿ
    ```
  </Accordion>
</AccordionGroup>

## ç†è§£ä»£ç 

<Tabs>
  <Tab title="ç±»å‹æç¤º">
    ```python
    async def read_resource(self, uri: str) -> ReadResourceResult:
        # ...
    ```

    Python ç±»å‹æç¤ºæœ‰åŠ©äºå°½æ—©å‘ç°é”™è¯¯å¹¶æé«˜ä»£ç å¯ç»´æŠ¤æ€§ã€‚
  </Tab>

  <Tab title="èµ„æº">
    ```python
    @app.list_resources()
    async def list_resources(self) -> ListResourcesResult:
        return ListResourcesResult(
            resources=[
                Resource(
                    uri=f"weather://{DEFAULT_CITY}/current",
                    name=f"{DEFAULT_CITY} çš„å½“å‰å¤©æ°”",
                    mimeType="application/json",
                    description="å®æ—¶å¤©æ°”æ•°æ®"
                )
            ]
        )
    ```

    èµ„æºæä¾› Claude å¯ä»¥ä½œä¸ºä¸Šä¸‹æ–‡è®¿é—®çš„æ•°æ®ã€‚
  </Tab>

  <Tab title="å·¥å…·">
    ```python
    Tool(
        name="get_forecast",
        description="è·å–åŸå¸‚çš„å¤©æ°”é¢„æŠ¥",
        inputSchema={
            "type": "object",
            "properties": {
                "city": {
                    "type": "string",
                    "description": "åŸå¸‚åç§°"
                },
                "days": {
                    "type": "number",
                    "description": "å¤©æ•°ï¼ˆ1-5ï¼‰",
                    "minimum": 1,
                    "maximum": 5
                }
            },
            "required": ["city"]
        }
    )
    ```

    å·¥å…·è®© Claude èƒ½å¤Ÿé€šè¿‡ä½ çš„æœåŠ¡å™¨æ‰§è¡ŒéªŒè¯è¾“å…¥çš„æ“ä½œã€‚
  </Tab>

  <Tab title="æœåŠ¡å™¨ç»“æ„">
    ```python
    # ä½¿ç”¨åç§°åˆ›å»ºæœåŠ¡å™¨å®ä¾‹
    app = Server("weather-server")

    # æ³¨å†Œèµ„æºå¤„ç†ç¨‹åº
    @app.list_resources()
    async def list_resources() -> list[Resource]:
        """åˆ—å‡ºå¯ç”¨èµ„æº"""
        return [...]

    # æ³¨å†Œå·¥å…·å¤„ç†ç¨‹åº
    @app.call_tool()
    async def call_tool(name: str, arguments: Any) -> Sequence[TextContent]:
        """å¤„ç†å·¥å…·æ‰§è¡Œ"""
        return [...]

    # æ³¨å†Œå…¶ä»–å¤„ç†ç¨‹åº
    @app.read_resource()
    ...
    @app.list_tools()
    ...
    ```

    MCP æœåŠ¡å™¨ä½¿ç”¨ç®€å•çš„åº”ç”¨æ¨¡å¼ - åˆ›å»ºä¸€ä¸ª Server å®ä¾‹å¹¶ç”¨è£…é¥°å™¨æ³¨å†Œå¤„ç†ç¨‹åºã€‚æ¯ä¸ªå¤„ç†ç¨‹åºéƒ½æ˜ å°„åˆ°ç‰¹å®šçš„ MCP åè®®æ“ä½œã€‚
  </Tab>
</Tabs>

## æœ€ä½³å®è·µ

<CardGroup cols={1}>
  <Card title="é”™è¯¯å¤„ç†" icon="shield">
    ```python
    try:
        async with httpx.AsyncClient() as client:
            response = await client.get(..., params={..., **http_params})
            response.raise_for_status()
    except httpx.HTTPError as e:
        raise McpError(
            ErrorCode.INTERNAL_ERROR,
            f"API é”™è¯¯ï¼š{str(e)}"
        )
    ```
  </Card>

  <Card title="ç±»å‹éªŒè¯" icon="check">
    ```python
    if not isinstance(args, dict) or "city" not in args:
        raise McpError(
            ErrorCode.INVALID_PARAMS,
            "æ— æ•ˆçš„é¢„æŠ¥å‚æ•°"
        )
    ```
  </Card>

  <Card title="ç¯å¢ƒå˜é‡" icon="gear">
    ```python
    if not API_KEY:
        raise ValueError("éœ€è¦ OPENWEATHER_API_KEY")
    ```
  </Card>

</CardGroup>

## å¯ç”¨çš„ä¼ è¾“æ–¹å¼

è™½ç„¶æœ¬æŒ‡å—ä½¿ç”¨ stdio ä¼ è¾“ï¼Œä½† MCP æ”¯æŒé¢å¤–çš„ä¼ è¾“é€‰é¡¹ï¼š

### SSEï¼ˆæœåŠ¡å™¨å‘é€äº‹ä»¶ï¼‰

```python
from mcp.server.sse import SseServerTransport
from starlette.applications import Starlette
from starlette.routing import Route

# åˆ›å»ºå¸¦æœ‰ç«¯ç‚¹çš„ SSE ä¼ è¾“
sse = SseServerTransport("/messages")

# SSE è¿æ¥çš„å¤„ç†ç¨‹åº
async def handle_sse(scope, receive, send):
    async with sse.connect_sse(scope, receive, send) as streams:
        await app.run(
            streams[0], streams[1], app.create_initialization_options()
        )

# å®¢æˆ·ç«¯æ¶ˆæ¯çš„å¤„ç†ç¨‹åº
async def handle_messages(scope, receive, send):
    await sse.handle_post_message(scope, receive, send)

# åˆ›å»ºå¸¦æœ‰è·¯ç”±çš„ Starlette åº”ç”¨
app = Starlette(
    debug=True,
    routes=[
        Route("/sse", endpoint=handle_sse),
        Route("/messages", endpoint=handle_messages, methods=["POST"]),
    ],
)

# ä½¿ç”¨ä»»ä½• ASGI æœåŠ¡å™¨è¿è¡Œ
import uvicorn
uvicorn.run(app, host="0.0.0.0", port=8000)
```

## é«˜çº§åŠŸèƒ½

<Steps>
  <Step title="ç†è§£è¯·æ±‚ä¸Šä¸‹æ–‡">
    è¯·æ±‚ä¸Šä¸‹æ–‡æä¾›å¯¹å½“å‰è¯·æ±‚å…ƒæ•°æ®å’Œæ´»åŠ¨å®¢æˆ·ç«¯ä¼šè¯çš„è®¿é—®ã€‚é€šè¿‡ `server.request_context` è®¿é—®ï¼š

    ```python
    @app.call_tool()
    async def call_tool(name: str, arguments: Any) -> Sequence[TextContent]:
        # è®¿é—®å½“å‰è¯·æ±‚ä¸Šä¸‹æ–‡
        ctx = self.request_context

        # è·å–è¯·æ±‚å…ƒæ•°æ®ï¼Œå¦‚è¿›åº¦ä»¤ç‰Œ
        if progress_token := ctx.meta.progressToken:
            # é€šè¿‡ä¼šè¯å‘é€è¿›åº¦é€šçŸ¥
            await ctx.session.send_progress_notification(
                progress_token=progress_token,
                progress=0.5,
                total=1.0
            )

        # ä» LLM å®¢æˆ·ç«¯é‡‡æ ·
        result = await ctx.session.create_message(
            messages=[
                SamplingMessage(
                    role="user",
                    content=TextContent(
                        type="text",
                        text="åˆ†æè¿™ä¸ªå¤©æ°”æ•°æ®ï¼š" + json.dumps(arguments)
                    )
                )
            ],
            max_tokens=100
        )

        return [TextContent(type="text", text=result.content.text)]
    ```
  </Step>

  <Step title="æ·»åŠ ç¼“å­˜">
    ```python
    # ç¼“å­˜è®¾ç½®
    cache_timeout = timedelta(minutes=15)
    last_cache_time = None
    cached_weather = None

    async def fetch_weather(city: str) -> dict[str, Any]:
        global cached_weather, last_cache_time

        now = datetime.now()
        if (cached_weather is None or
            last_cache_time is None or
            now - last_cache_time > cache_timeout):

            async with httpx.AsyncClient() as client:
                response = await client.get(
                    f"{API_BASE_URL}/{CURRENT_WEATHER_ENDPOINT}",
                    params={"q": city, **http_params}
                )
                response.raise_for_status()
                data = response.json()

            cached_weather = {
                "temperature": data["main"]["temp"],
                "conditions": data["weather"][0]["description"],
                "humidity": data["main"]["humidity"],
                "wind_speed": data["wind"]["speed"],
                "timestamp": datetime.now().isoformat()
            }
            last_cache_time = now

        return cached_weather
    ```
  </Step>

  <Step title="æ·»åŠ è¿›åº¦é€šçŸ¥">
    ```python
    @self.call_tool()
    async def call_tool(self, name: str, arguments: Any) -> CallToolResult:
        if progress_token := self.request_context.meta.progressToken:
            # å‘é€è¿›åº¦é€šçŸ¥
            await self.request_context.session.send_progress_notification(
                progress_token=progress_token,
                progress=1,
                total=2
            )

            # è·å–æ•°æ®...

            await self.request_context.session.send_progress_notification(
                progress_token=progress_token,
                progress=2,
                total=2
            )

        # æ–¹æ³•å®ç°çš„å…¶ä½™éƒ¨åˆ†...
    ```
  </Step>

  <Step title="æ·»åŠ æ—¥å¿—æ”¯æŒ">
    ```python
    # è®¾ç½®æ—¥å¿—
    logger = logging.getLogger("weather-server")
    logger.setLevel(logging.INFO)

    @app.set_logging_level()
    async def set_logging_level(level: LoggingLevel) -> EmptyResult:
        logger.setLevel(level.upper())
        await app.request_context.session.send_log_message(
            level="info",
            data=f"æ—¥å¿—çº§åˆ«è®¾ç½®ä¸º {level}",
            logger="weather-server"
        )
        return EmptyResult()

    # åœ¨æ•´ä¸ªä»£ç ä¸­ä½¿ç”¨ logger
    # ä¾‹å¦‚ï¼š
    # logger.info("æˆåŠŸè·å–å¤©æ°”æ•°æ®")
    # logger.error(f"è·å–å¤©æ°”æ•°æ®å‡ºé”™ï¼š{str(e)}")
    ```
  </Step>

  <Step title="æ·»åŠ èµ„æºæ¨¡æ¿">
    ```python
    @app.list_resource_templates()
    async def list_resource_templates() -> list[ResourceTemplate]:
        return [
            ResourceTemplate(
                uriTemplate="weather://{city}/current",
                name="ä»»æ„åŸå¸‚çš„å½“å‰å¤©æ°”",
                mimeType="application/json"
            )
        ]
    ```
  </Step>
</Steps>

## æµ‹è¯•

<Steps>
  <Step title="åˆ›å»ºæµ‹è¯•æ–‡ä»¶">
  åˆ›å»º `tests/weather_test.py`ï¼š

  ```python
  import pytest
  import os
  from unittest.mock import patch, Mock
  from datetime import datetime
  import json
  from pydantic import AnyUrl
  os.environ["OPENWEATHER_API_KEY"] = "TEST"

  from weather_service.server import (
      fetch_weather,
      read_resource,
      call_tool,
      list_resources,
      list_tools,
      DEFAULT_CITY
  )

  @pytest.fixture
  def anyio_backend():
      return "asyncio"

  @pytest.fixture
  def mock_weather_response():
      return {
          "main": {
              "temp": 20.5,
              "humidity": 65
          },
          "weather": [
              {"description": "é›¶æ•£äº‘æœµ"}
          ],
          "wind": {
              "speed": 3.6
          }
      }

  @pytest.fixture
  def mock_forecast_response():
      return {
          "list": [
              {
                  "dt_txt": "2024-01-01 12:00:00",
                  "main": {"temp": 18.5},
                  "weather": [{"description": "æ™´å¤©"}]
              },
              {
                  "dt_txt": "2024-01-02 12:00:00",
                  "main": {"temp": 17.2},
                  "weather": [{"description": "å¤šäº‘"}]
              }
          ]
      }

  @pytest.mark.anyio
  async def test_fetch_weather(mock_weather_response):
      with patch('requests.Session.get') as mock_get:
          mock_get.return_value.json.return_value = mock_weather_response
          mock_get.return_value.raise_for_status = Mock()

          weather = await fetch_weather("London")

          assert weather["temperature"] == 20.5
          assert weather["conditions"] == "é›¶æ•£äº‘æœµ"
          assert weather["humidity"] == 65
          assert weather["wind_speed"] == 3.6
          assert "timestamp" in weather

  @pytest.mark.anyio
  async def test_read_resource():
      with patch('weather_service.server.fetch_weather') as mock_fetch:
          mock_fetch.return_value = {
              "temperature": 20.5,
              "conditions": "æ™´æœ—",
              "timestamp": datetime.now().isoformat()
          }

          uri = AnyUrl("weather://London/current")
          result = await read_resource(uri)

          assert isinstance(result, str)
          assert "temperature" in result
          assert "æ™´æœ—" in result

  @pytest.mark.anyio
  async def test_call_tool(mock_forecast_response):
      class Response():
          def raise_for_status(self):
              pass

          def json(self):
              return mock_forecast_response

      class AsyncClient():
          def __aenter__(self):
              return self

          async def __aexit__(self, *exc_info):
              pass

          async def get(self, *args, **kwargs):
              return Response()

      with patch('httpx.AsyncClient', new=AsyncClient) as mock_client:
          result = await call_tool("get_forecast", {"city": "London", "days": 2})

          assert len(result) == 1
          assert result[0].type == "text"
          forecast_data = json.loads(result[0].text)
          assert len(forecast_data) == 1
          assert forecast_data[0]["temperature"] == 18.5
          assert forecast_data[0]["conditions"] == "æ™´å¤©"

  @pytest.mark.anyio
  async def test_list_resources():
      resources = await list_resources()
      assert len(resources) == 1
      assert resources[0].name == f"{DEFAULT_CITY} çš„å½“å‰å¤©æ°”"
      assert resources[0].mimeType == "application/json"

  @pytest.mark.anyio
  async def test_list_tools():
      tools = await list_tools()
      assert len(tools) == 1
      assert tools[0].name == "get_forecast"
      assert "city" in tools[0].inputSchema["properties"]
  ```
  </Step>
  
  <Step title="è¿è¡Œæµ‹è¯•">
  ```bash
  uv add --dev pytest
  uv run pytest
  ```
  </Step>
</Steps>

## æ•…éšœæ’é™¤

### å®‰è£…é—®é¢˜

```bash
# æ£€æŸ¥ Python ç‰ˆæœ¬
python --version

# é‡æ–°å®‰è£…ä¾èµ–é¡¹
uv sync --reinstall
```

### ç±»å‹æ£€æŸ¥

```bash
# å®‰è£… mypy
uv add --dev pyright

# è¿è¡Œç±»å‹æ£€æŸ¥å™¨
uv run pyright src
```

## ä¸‹ä¸€æ­¥

<CardGroup cols={2}>
  <Card title="æ¶æ„æ¦‚è§ˆ" icon="sitemap" href="/docs/concepts/architecture">
    äº†è§£æ›´å¤šå…³äº MCP æ¶æ„çš„ä¿¡æ¯
  </Card>

  <Card title="Python SDK" icon="python" href="https://github.com/modelcontextprotocol/python-sdk">
    åœ¨ GitHub ä¸ŠæŸ¥çœ‹ Python SDK
  </Card>
</CardGroup>