---
title: "TypeScript"
description: "15 分钟内用 TypeScript 创建一个简单的 MCP 服务器"
---

让我们用 TypeScript 构建你的第一个 MCP 服务器！我们将创建一个天气服务器，它提供当前天气数据作为资源，并让 Claude 使用工具获取天气预报。

<Note>
本指南使用 OpenWeatherMap API。你需要从 [OpenWeatherMap](https://openweathermap.org/api) 获取一个免费的 API 密钥才能继续。
</Note>

## 前提条件

<Steps>
  <Step title="安装 Node.js">
    你需要 Node.js 18 或更高版本：
    
    ```bash
    node --version  # 应为 v18 或更高版本
    npm --version
    ```
  </Step>

  <Step title="创建新项目">
    你可以使用我们的 [create-typescript-server](https://github.com/modelcontextprotocol/create-typescript-server) 工具来初始化一个新项目：

    ```bash
    npx @modelcontextprotocol/create-server weather-server
    cd weather-server
    ```
  </Step>

  <Step title="安装依赖">
    ```bash
    npm install --save axios dotenv
    ```
  </Step>

  <Step title="设置环境">
    创建 `.env`：
    ```bash
    OPENWEATHER_API_KEY=你的 API 密钥
    ```
    确保将环境文件添加到 `.gitignore`
    ```bash
    .env
    ```
  </Step>
</Steps>

## 创建服务器

<Steps>
  <Step title="定义类型">
    创建文件 `src/types.ts`，并添加以下内容：

    ```typescript
    export interface OpenWeatherResponse {
      main: {
        temp: number;
        humidity: number;
      };
      weather: Array<{
        description: string;
      }>;
      wind: {
        speed: number;
      };
      dt_txt?: string;
    }

    export interface WeatherData {
      temperature: number;
      conditions: string;
      humidity: number;
      wind_speed: number;
      timestamp: string;
    }

    export interface ForecastDay {
      date: string;
      temperature: number;
      conditions: string;
    }

    export interface GetForecastArgs {
      city: string;
      days?: number;
    }

    // 类型守卫用于预报参数
    export function isValidForecastArgs(args: any): args is GetForecastArgs {
      return (
        typeof args === "object" && 
        args !== null && 
        "city" in args &&
        typeof args.city === "string" &&
        (args.days === undefined || typeof args.days === "number")
      );
    }
    ```
  </Step>

  <Step title="添加基础代码">
    用以下内容替换 `src/index.ts`：

    ```typescript
    #!/usr/bin/env node
    import { Server } from "@modelcontextprotocol/sdk/server/index.js";
    import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
    import {
      ListResourcesRequestSchema,
      ReadResourceRequestSchema,
      ListToolsRequestSchema,
      CallToolRequestSchema,
      ErrorCode,
      McpError
    } from "@modelcontextprotocol/sdk/types.js";
    import axios from "axios";
    import dotenv from "dotenv";
    import { 
      WeatherData, 
      ForecastDay, 
      OpenWeatherResponse,
      isValidForecastArgs 
    } from "./types.js";

    dotenv.config();

    const API_KEY = process.env.OPENWEATHER_API_KEY;
    if (!API_KEY) {
      throw new Error("需要 OPENWEATHER_API_KEY 环境变量");
    }

    const API_CONFIG = {
      BASE_URL: 'http://api.openweathermap.org/data/2.5',
      DEFAULT_CITY: '旧金山',
      ENDPOINTS: {
        CURRENT: 'weather',
        FORECAST: 'forecast'
      }
    } as const;

    class WeatherServer {
      private server: Server;
      private axiosInstance;

      constructor() {
        this.server = new Server({
          name: "example-weather-server",
          version: "0.1.0"
        }, {
          capabilities: {
            resources: {},
            tools: {}
          }
        });

        // 配置 axios 默认值
        this.axiosInstance = axios.create({
          baseURL: API_CONFIG.BASE_URL,
          params: {
            appid: API_KEY,
            units: "metric"
          }
        });

        this.setupHandlers();
        this.setupErrorHandling();
      }

      private setupErrorHandling(): void {
        this.server.onerror = (error) => {
          console.error("[MCP 错误]", error);
        };

        process.on('SIGINT', async () => {
          await this.server.close();
          process.exit(0);
        });
      }

      private setupHandlers(): void {
        this.setupResourceHandlers();
        this.setupToolHandlers();
      }

      private setupResourceHandlers(): void {
        // 实现在下一节继续
      }

      private setupToolHandlers(): void {
        // 实现在下一节继续
      }

      async run(): Promise<void> {
        const transport = new StdioServerTransport();
        await this.server.connect(transport);
        
        // 虽然这只是一条信息，但我们必须记录到 stderr，
        // 以避免干扰在 stdout 上进行的 MCP 通信
        console.error("天气 MCP 服务器正在通过 stdio 运行");
      }
    }

    const server = new WeatherServer();
    server.run().catch(console.error);
    ```
  </Step>

  <Step title="添加资源处理程序">
    将以下内容添加到 `setupResourceHandlers` 方法中：

    ```typescript
    private setupResourceHandlers(): void {
      this.server.setRequestHandler(
        ListResourcesRequestSchema,
        async () => ({
          resources: [{
            uri: `weather://${API_CONFIG.DEFAULT_CITY}/current`,
            name: `${API_CONFIG.DEFAULT_CITY}的当前天气`,
            mimeType: "application/json",
            description: "实时天气数据，包括温度、天气状况、湿度和风速"
          }]
        })
      );

      this.server.setRequestHandler(
        ReadResourceRequestSchema,
        async (request) => {
          const city = API_CONFIG.DEFAULT_CITY;
          if (request.params.uri !== `weather://${city}/current`) {
            throw new McpError(
              ErrorCode.InvalidRequest,
              `未知资源：${request.params.uri}`
            );
          }

          try {
            const response = await this.axiosInstance.get<OpenWeatherResponse>(
              API_CONFIG.ENDPOINTS.CURRENT,
              {
                params: { q: city }
              }
            );

            const weatherData: WeatherData = {
              temperature: response.data.main.temp,
              conditions: response.data.weather[0].description,
              humidity: response.data.main.humidity,
              wind_speed: response.data.wind.speed,
              timestamp: new Date().toISOString()
            };

            return {
              contents: [{
                uri: request.params.uri,
                mimeType: "application/json",
                text: JSON.stringify(weatherData, null, 2)
              }]
            };
          } catch (error) {
            if (axios.isAxiosError(error)) {
              throw new McpError(
                ErrorCode.InternalError,
                `天气 API 错误：${error.response?.data.message ?? error.message}`
              );
            }
            throw error;
          }
        }
      );
    }
    ```
  </Step>

  <Step title="添加工具处理程序">
    将以下处理程序添加到 `setupToolHandlers` 方法中：

    ```typescript
    private setupToolHandlers(): void {
      this.server.setRequestHandler(
        ListToolsRequestSchema,
        async () => ({
          tools: [{
            name: "get_forecast",
            description: "获取城市的天气预报",
            inputSchema: {
              type: "object",
              properties: {
                city: {
                  type: "string",
                  description: "城市名称"
                },
                days: {
                  type: "number",
                  description: "天数（1-5）",
                  minimum: 1,
                  maximum: 5
                }
              },
              required: ["city"]
            }
          }]
        })
      );

      this.server.setRequestHandler(
        CallToolRequestSchema,
        async (request) => {
          if (request.params.name !== "get_forecast") {
            throw new McpError(
              ErrorCode.MethodNotFound,
              `未知工具：${request.params.name}`
            );
          }

          if (!isValidForecastArgs(request.params.arguments)) {
            throw new McpError(
              ErrorCode.InvalidParams,
              "无效的预报参数"
            );
          }

          const city = request.params.arguments.city;
          const days = Math.min(request.params.arguments.days || 3, 5);

          try {
            const response = await this.axiosInstance.get<{
              list: OpenWeatherResponse[]
            }>(API_CONFIG.ENDPOINTS.FORECAST, {
              params: {
                q: city,
                cnt: days * 8 // API 返回 3 小时间隔的数据
              }
            });

            const forecasts: ForecastDay[] = [];
            for (let i = 0; i < response.data.list.length; i += 8) {
              const dayData = response.data.list[i];
              forecasts.push({
                date: dayData.dt_txt?.split(' ')[0] ?? new Date().toISOString().split('T')[0],
                temperature: dayData.main.temp,
                conditions: dayData.weather[0].description
              });
            }

            return {
              content: [{
                type: "text",
                text: JSON.stringify(forecasts, null, 2)
              }]
            };
          } catch (error) {
            if (axios.isAxiosError(error)) {
              return {
                content: [{
                  type: "text",
                  text: `天气 API 错误：${error.response?.data.message ?? error.message}`
                }],
                isError: true,
              }
            }
            throw error;
          }
        }
      );
    }
    ```
  </Step>

  <Step title="构建和测试">
    ```bash
    npm run build
    ```
  </Step>
</Steps>

## 连接到 Claude Desktop

<Steps>
  <Step title="更新 Claude 配置">
    如果你在项目设置期间没有连接到 Claude Desktop，请在 `claude_desktop_config.json` 中添加：

    ```json
    {
      "mcpServers": {
        "weather": {
          "command": "node",
          "args": ["/path/to/weather-server/build/index.js"],
          "env": {
            "OPENWEATHER_API_KEY": "你的 API 密钥",
          }
        }
      }
    }
    ```
  </Step>

  <Step title="重启 Claude">
    1. 完全退出 Claude
    2. 重新启动 Claude
    3. 在 🔌 菜单中查找你的天气服务器
  </Step>
</Steps>

## 试一试！

<AccordionGroup>
  <Accordion title="查看当前天气" active>
    问 Claude：
    ```
    旧金山现在的天气如何？你能分析一下天气状况吗？
    ```
  </Accordion>

  <Accordion title="获取天气预报">
    问 Claude：
    ```
    你能给我一个东京的 5 天天气预报，告诉我是否需要带伞吗？
    ```
  </Accordion>

  <Accordion title="比较天气">
    问 Claude：
    ```
    你能分析一下东京和旧金山的天气预报，告诉我本周哪个城市会更暖和吗？
    ```
  </Accordion>
</AccordionGroup>

## 理解代码

<Tabs>
  <Tab title="类型安全">
    ```typescript
    interface WeatherData {
      temperature: number;
      conditions: string;
      humidity: number;
      wind_speed: number;
      timestamp: string;
    }
    ```
    TypeScript 为我们的 MCP 服务器增加了类型安全性，使其更可靠且易于维护。
  </Tab>

  <Tab title="资源">
    ```typescript
    this.server.setRequestHandler(
      ListResourcesRequestSchema,
      async () => ({
        resources: [{
          uri: `weather://${DEFAULT_CITY}/current`,
          name: `${DEFAULT_CITY}的当前天气`,
          mimeType: "application/json"
        }]
      })
    );
    ```
    资源提供 Claude 可以作为上下文访问的数据。
  </Tab>

  <Tab title="工具">
    ```typescript
    {
      name: "get_forecast",
      description: "获取城市的天气预报",
      inputSchema: {
        type: "object",
        properties: {
          city: { type: "string" },
          days: { type: "number" }
        }
      }
    }
    ```
    工具让 Claude 能够通过你的服务器使用类型安全的输入执行操作。
  </Tab>
</Tabs>

## 最佳实践

<CardGroup cols={1}>
  <Card
    title="错误处理"
    icon="shield"
  >
    当工具遇到错误时，返回带有 `isError: true` 的错误消息，以便模型可以自我纠正：

    ```typescript
    try {
      const response = await axiosInstance.get(...);
    } catch (error) {
      if (axios.isAxiosError(error)) {
        return {
          content: {
            mimeType: "text/plain",
            text: `天气 API 错误：${error.response?.data.message ?? error.message}`
          },
          isError: true,
        }
      }
      throw error;
    }
    ```

    对于其他处理程序，抛出错误，以便应用程序可以通知用户：

    ```typescript
    try {
      const response = await this.axiosInstance.get(...);
    } catch (error) {
      if (axios.isAxiosError(error)) {
        throw new McpError(
          ErrorCode.InternalError,
          `天气 API 错误：${error.response?.data.message}`
        );
      }
      throw error;
    }
    ```
  </Card>

  <Card title="类型验证"
    icon="check"
  >
    ```typescript
    function isValidForecastArgs(args: any): args is GetForecastArgs {
      return (
        typeof args === "object" && 
        args !== null && 
        "city" in args &&
        typeof args.city === "string"
      );
    }
    ```

    <Tip>你也可以使用像 [Zod](https://zod.dev/) 这样的库来自动执行此验证。</Tip>
  </Card>
</CardGroup>

## 可用传输

虽然本指南使用 stdio 将 MCP 服务器作为本地进程运行，但 MCP 也支持其他[传输](/docs/concepts/transports)。

## 故障排除

<Info>
  以下故障排除提示适用于 macOS。其他平台的指南即将推出。
</Info>

### 构建错误
```bash
# 检查 TypeScript 版本
npx tsc --version

# 清理并重新构建
rm -rf build/
npm run build
```

### 运行时错误
在 Claude Desktop 日志中查找详细的错误消息：
```bash
# 监控日志
tail -n 20 -f ~/Library/Logs/Claude/mcp*.log
```

### 类型错误
```bash
# 不构建的情况下检查类型
npx tsc --noEmit
```

## 下一步

<CardGroup cols={2}>
  <Card
    title="架构概述"
    icon="sitemap"
    href="/docs/concepts/architecture"
  >
    了解更多关于 MCP 架构的信息
  </Card>

  <Card
    title="TypeScript SDK"
    icon="square-js"
    href="https://github.com/modelcontextprotocol/typescript-sdk"
  >
    在 GitHub 上查看 TypeScript SDK
  </Card>
</CardGroup>

<Note>
需要帮助？问问 Claude！由于它可以访问 MCP SDK 文档，它可以帮助你调试问题并建议改进你的服务器。
</Note>